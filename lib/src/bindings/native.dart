// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Linux bindings to all posix apis
class native {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  native(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  native.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int socket(
    int __domain,
    int __type,
    int __protocol,
  ) {
    return _socket(
      __domain,
      __type,
      __protocol,
    );
  }

  late final _socketPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'socket');
  late final _socket = _socketPtr.asFunction<int Function(int, int, int)>();

  int bind(
    int __fd,
    ffi.Pointer<sockaddr> __addr,
    int __len,
  ) {
    return _bind(
      __fd,
      __addr,
      __len,
    );
  }

  late final _bindPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<sockaddr>, ffi.UnsignedInt)>>('bind');
  late final _bind =
      _bindPtr.asFunction<int Function(int, ffi.Pointer<sockaddr>, int)>();

  int getsockname(
    int __fd,
    ffi.Pointer<sockaddr> __addr,
    ffi.Pointer<ffi.UnsignedInt> __len,
  ) {
    return _getsockname(
      __fd,
      __addr,
      __len,
    );
  }

  late final _getsocknamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<sockaddr>,
              ffi.Pointer<ffi.UnsignedInt>)>>('getsockname');
  late final _getsockname = _getsocknamePtr.asFunction<
      int Function(int, ffi.Pointer<sockaddr>, ffi.Pointer<ffi.UnsignedInt>)>();

  int send(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __n,
    int __flags,
  ) {
    return _send(
      __fd,
      __buf,
      __n,
      __flags,
    );
  }

  late final _sendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(
              ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size, ffi.Int)>>('send');
  late final _send =
      _sendPtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int)>();

  /// Convert an interface name to an index, and vice versa.
  int if_nametoindex(
    ffi.Pointer<ffi.Char> __ifname,
  ) {
    return _if_nametoindex(
      __ifname,
    );
  }

  late final _if_nametoindexPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<ffi.Char>)>>(
      'if_nametoindex');
  late final _if_nametoindex =
      _if_nametoindexPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int close(
    int __fd,
  ) {
    return _close(
      __fd,
    );
  }

  late final _closePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('close');
  late final _close = _closePtr.asFunction<int Function(int)>();

  int read(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __nbytes,
  ) {
    return _read(
      __fd,
      __buf,
      __nbytes,
    );
  }

  late final _readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)>>('read');
  late final _read =
      _readPtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  int write(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __n,
  ) {
    return _write(
      __fd,
      __buf,
      __n,
    );
  }

  late final _writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(
              ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)>>('write');
  late final _write =
      _writePtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();
}

final class sockaddr extends ffi.Struct {
  @ffi.UnsignedShort()
  external int sa_family;

  @ffi.Array.multi([14])
  external ffi.Array<ffi.Char> sa_data;
}

/// Interface request structure used for socket ioctl's.  All interface
/// ioctl's must have parameter definitions which begin with ifr_name.
/// The remainder may be interface specific.
final class ifreq extends ffi.Struct {
  external UnnamedUnion1 ifr_ifrn;

  external UnnamedUnion2 ifr_ifru;
}

final class UnnamedUnion1 extends ffi.Union {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> ifrn_name;
}

final class UnnamedUnion2 extends ffi.Union {
  external sockaddr ifru_addr;

  external sockaddr ifru_dstaddr;

  external sockaddr ifru_broadaddr;

  external sockaddr ifru_netmask;

  external sockaddr ifru_hwaddr;

  @ffi.Short()
  external int ifru_flags;

  @ffi.Int()
  external int ifru_ivalue;

  @ffi.Int()
  external int ifru_mtu;

  external ifmap ifru_map;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> ifru_slave;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> ifru_newname;

  external ffi.Pointer<ffi.Char> ifru_data;
}

/// Device mapping structure. I'd just gone off and designed a
/// beautiful scheme using only loadable modules with arguments for
/// driver options and along come the PCMCIA people 8)
///
/// Ah well. The get() side of this is good for WDSETUP, and it'll be
/// handy for debugging things. The set side is fine for now and being
/// very small might be worth keeping for clean configuration.
final class ifmap extends ffi.Struct {
  @ffi.UnsignedLong()
  external int mem_start;

  @ffi.UnsignedLong()
  external int mem_end;

  @ffi.UnsignedShort()
  external int base_addr;

  @ffi.UnsignedChar()
  external int irq;

  @ffi.UnsignedChar()
  external int dma;

  @ffi.UnsignedChar()
  external int port;
}

/// struct can_frame - basic CAN frame structure
/// @can_id:  CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition
/// @can_dlc: frame payload length in byte (0 .. 8) aka data length code
/// N.B. the DLC field from ISO 11898-1 Chapter 8.4.2.3 has a 1:1
/// mapping of the 'data length code' to the real payload length
/// @__pad:   padding
/// @__res0:  reserved / padding
/// @__res1:  reserved / padding
/// @data:    CAN frame payload (up to 8 byte)
final class can_frame extends ffi.Struct {
  /// 32 bit CAN_ID + EFF/RTR/ERR flags
  @ffi.UnsignedInt()
  external int can_id;

  /// frame payload length in byte (0 .. CAN_MAX_DLEN)
  @ffi.UnsignedChar()
  external int can_dlc;

  /// padding
  @ffi.UnsignedChar()
  external int __pad;

  /// reserved / padding
  @ffi.UnsignedChar()
  external int __res0;

  /// reserved / padding
  @ffi.UnsignedChar()
  external int __res1;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.UnsignedChar> data;
}

/// struct sockaddr_can - the sockaddr structure for CAN sockets
/// @can_family:  address family number AF_CAN.
/// @can_ifindex: CAN network interface index.
/// @can_addr:    protocol specific address information
final class sockaddr_can extends ffi.Struct {
  @ffi.UnsignedShort()
  external int can_family;

  @ffi.Int()
  external int can_ifindex;

  external UnnamedUnion3 can_addr;
}

final class UnnamedUnion3 extends ffi.Union {
  external UnnamedStruct1 tp;

  external UnnamedStruct2 j1939;
}

/// transport protocol class address information (e.g. ISOTP)
final class UnnamedStruct1 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int rx_id;

  @ffi.UnsignedInt()
  external int tx_id;
}

/// J1939 address information
final class UnnamedStruct2 extends ffi.Struct {
  /// 8 byte name when using dynamic addressing
  @ffi.UnsignedLongLong()
  external int name;

  /// pgn:
  /// 8 bit: PS in PDU2 case, else 0
  /// 8 bit: PF
  /// 1 bit: DP
  /// 1 bit: reserved
  @ffi.UnsignedInt()
  external int pgn;

  /// 1 byte address
  @ffi.UnsignedChar()
  external int addr;
}

/// struct can_filter - CAN ID based filter in can_register().
/// @can_id:   relevant bits of CAN ID which are not masked out.
/// @can_mask: CAN mask (see description)
///
/// Description:
/// A filter matches, when
///
/// <received_can_id> & mask == can_id & mask
///
/// The filter can be inverted (CAN_INV_FILTER bit set in can_id) or it can
/// filter for error message frames (CAN_ERR_FLAG bit set in mask).
final class can_filter extends ffi.Struct {
  @ffi.UnsignedInt()
  external int can_id;

  @ffi.UnsignedInt()
  external int can_mask;
}

const int SOCK_RAW = 3;

const int PF_CAN = 29;

const int AF_CAN = 29;

const int SIOCGIFINDEX = 35123;

const int CAN_ERR_FLAG = 536870912;

const int CAN_RAW = 1;

const int CAN_INV_FILTER = 536870912;
